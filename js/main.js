// Generated by CoffeeScript 1.4.0
(function() {
  var Renderer, chemin;

  chemin = [];

  Renderer = function(canvas) {
    var ctx, gfx, intersect_line_box, intersect_line_line, particleSystem, that;
    canvas = $(canvas).get(0);
    ctx = canvas.getContext('2d');
    gfx = arbor.Graphics(canvas);
    particleSystem = null;
    that = {
      init: function(system) {
        particleSystem = system;
        particleSystem.screenSize(canvas.width, canvas.height);
        particleSystem.screenPadding(40);
        that.initMouseHandling();
      },
      redraw: function() {
        var nodeBoxes;
        if (!particleSystem) {
          return;
        }
        gfx.clear();
        nodeBoxes = {};
        particleSystem.eachNode(function(node, pt) {
          var label, w;
          label = node.data.label || '';
          w = ctx.measureText('' + label).width + 10;
          if (!('' + label).match(/^[ \t]*$/)) {
            pt.x = Math.floor(pt.x);
            pt.y = Math.floor(pt.y);
          } else {
            label = null;
          }
          if (node.data.color) {
            ctx.fillStyle = node.data.color;
          } else {
            ctx.fillStyle = 'rgba(0,0,0,.2)';
          }
          if (node.data.color === 'none') {
            ctx.fillStyle = 'white';
          }
          if (node.data.shape === 'dot') {
            gfx.oval(pt.x - (w / 2), pt.y - (w / 2), w, w, {
              fill: ctx.fillStyle
            });
            nodeBoxes[node.name] = [pt.x - (w / 2), pt.y - (w / 2), w, w];
          } else {
            gfx.rect(pt.x - (w / 2), pt.y - 10, w, 20, 4, {
              fill: ctx.fillStyle
            });
            nodeBoxes[node.name] = [pt.x - (w / 2), pt.y - 11, w, 22];
          }
          if (label) {
            ctx.font = '12px Helvetica';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            if (node.data.color === 'none') {
              ctx.fillStyle = '#333333';
            }
            ctx.fillText(label || '', pt.x, pt.y + 4);
            ctx.fillText(label || '', pt.x, pt.y + 4);
          }
        });
        particleSystem.eachEdge(function(edge, pt1, pt2) {
          var arrowLength, arrowWidth, color, head, tail, weight, wt;
          weight = edge.data.weight;
          color = edge.data.color;
          if (!color || ('' + color).match(/^[ \t]*$/)) {
            color = null;
          }
          tail = intersect_line_box(pt1, pt2, nodeBoxes[edge.source.name]);
          head = intersect_line_box(tail, pt2, nodeBoxes[edge.target.name]);
          ctx.save();
          ctx.beginPath();
          ctx.lineWidth = !isNaN(weight) ? parseFloat(weight) : 1;
          ctx.strokeStyle = color ? color : '#cccccc';
          ctx.fillStyle = null;
          ctx.moveTo(tail.x, tail.y);
          ctx.lineTo(head.x, head.y);
          ctx.stroke();
          ctx.restore();
          if (edge.data.directed) {
            ctx.save();
            wt = !isNaN(weight) ? parseFloat(weight) : 1;
            arrowLength = 6 + wt;
            arrowWidth = 2 + wt;
            ctx.fillStyle = color ? color : '#cccccc';
            ctx.translate(head.x, head.y);
            ctx.rotate(Math.atan2(head.y - tail.y, head.x - tail.x));
            ctx.clearRect(-arrowLength / 2, -wt / 2, arrowLength / 2, wt);
            ctx.beginPath();
            ctx.moveTo(-arrowLength, arrowWidth);
            ctx.lineTo(0, 0);
            ctx.lineTo(-arrowLength, -arrowWidth);
            ctx.lineTo(-arrowLength * 0.8, -0);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }
        });
      },
      initMouseHandling: function() {
        var dragged, handler, nearest, oldmass, selected;
        selected = null;
        nearest = null;
        dragged = null;
        oldmass = 1;
        handler = {
          clicked: function(e) {
            var edges, last, pos, _mouseP;
            pos = $(canvas).offset();
            _mouseP = arbor.Point(e.pageX - pos.left, e.pageY - pos.top);
            selected = nearest = dragged = particleSystem.nearest(_mouseP);
            console.log("clicked point :", selected.node);
            particleSystem.tweenNode(selected.node, 0.5, {
              color: "blue"
            });
            if (chemin.length > 1) {
              last = chemin.pop();
              console.log(last);
              edges = particleSystem.getEdges(last, selected.node);
              console.log("found edges :", edges);
              particleSystem.tweenEdge(edges[0], 0.5, {
                weight: 10
              });
            }
            chemin.push(last);
            return chemin.push(selected.node);
          }
        };
        $(canvas).mousedown(handler.clicked);
      }
    };
    intersect_line_line = function(p1, p2, p3, p4) {
      var denom, ua, ub;
      denom = (p4.y - p3.y) * (p2.x - p1.x) - ((p4.x - p3.x) * (p2.y - p1.y));
      if (denom === 0) {
        return false;
      }
      ua = ((p4.x - p3.x) * (p1.y - p3.y) - ((p4.y - p3.y) * (p1.x - p3.x))) / denom;
      ub = ((p2.x - p1.x) * (p1.y - p3.y) - ((p2.y - p1.y) * (p1.x - p3.x))) / denom;
      if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
        return false;
      }
      return arbor.Point(p1.x + ua * (p2.x - p1.x), p1.y + ua * (p2.y - p1.y));
    };
    intersect_line_box = function(p1, p2, boxTuple) {
      var bl, br, h, p3, tl, tr, w;
      p3 = {
        x: boxTuple[0],
        y: boxTuple[1]
      };
      w = boxTuple[2];
      h = boxTuple[3];
      tl = {
        x: p3.x,
        y: p3.y
      };
      tr = {
        x: p3.x + w,
        y: p3.y
      };
      bl = {
        x: p3.x,
        y: p3.y + h
      };
      br = {
        x: p3.x + w,
        y: p3.y + h
      };
      return intersect_line_line(p1, p2, tl, tr) || intersect_line_line(p1, p2, tr, br) || intersect_line_line(p1, p2, br, bl) || intersect_line_line(p1, p2, bl, tl) || false;
    };
    return that;
  };

  ({
    clear: function() {
      return sys.eachNode(function(node) {
        return sys.pruneNode(node);
      });
    }
  });

  $(function() {
    var friction, i, j, repulsion, stiffness, sys, _i, _j, _k, _ref;
    _ref = [100, 50, 0.5], repulsion = _ref[0], stiffness = _ref[1], friction = _ref[2];
    sys = arbor.ParticleSystem();
    sys.parameters({
      repulsion: 100,
      stiffness: 50,
      friction: 0.5,
      gravity: true,
      precision: 0.005
    });
    sys.renderer = Renderer("#viewport");
    for (i = _i = 1; _i <= 5; i = ++_i) {
      sys.addNode(i, {
        'color': "red",
        'shape': 'dot',
        'label': " * ",
        'mass': "1"
      });
    }
    for (i = _j = 1; _j <= 5; i = ++_j) {
      for (j = _k = 1; _k <= 5; j = ++_k) {
        sys.addEdge(i, j, {
          type: "arrow",
          directed: true,
          color: "black",
          weight: 1,
          length: 10
        });
      }
    }
    $("#slider-repulsion").slider({
      range: "max",
      min: 1,
      max: 3000,
      step: 10,
      value: repulsion,
      slide: function(event, ui) {
        $("#amount-repulsion").html(ui.value);
        return sys.parameters({
          repulsion: ui.value
        });
      }
    });
    $("#amount-repulsion").html(repulsion);
    $("#slider-stiffness").slider({
      range: "max",
      min: 1,
      max: 3000,
      step: 10,
      value: stiffness,
      slide: function(event, ui) {
        $("#amount-stiffness").html(ui.value);
        return sys.parameters({
          stiffness: ui.value
        });
      }
    });
    $("#amount-stiffness").html(stiffness);
    return $("#slider-friction").slider({
      range: "max",
      min: 0,
      max: 1,
      step: 0.1,
      value: friction,
      slide: function(event, ui) {
        $("#amount-friction").html(ui.value);
        return sys.parameters({
          friction: ui.value
        });
      }
    }, $("#amount-friction").html(friction));
  });

}).call(this);
